import { Injectable } from '@nestjs/common';
import { mkdir, readFile, writeFile, rename, unlink, chmod } from 'fs/promises';
import { join } from 'path';
import { createLogger } from '../../../common/logging/logger';

const logger = createLogger('HooksConfigService');

const SETTINGS_FILE_MODE = 0o600;
const SCRIPT_FILE_MODE = 0o755;

/**
 * Relay script embedded as a string constant.
 * Materialized to {projectRoot}/.claude/hooks/devchain-relay.sh at runtime.
 *
 * Requires: jq, curl (standard on dev machines).
 *
 * Flow:
 * 1. Reads Claude Code hook JSON from stdin
 * 2. Captures tmux session name
 * 3. Reads DEVCHAIN_* env vars injected by DevChain session launcher
 * 4. Constructs combined JSON payload with jq
 * 5. POSTs to DevChain API via curl
 * 6. Outputs hook-compatible JSON to stdout (bidirectional)
 * 7. Always exits 0 (never blocks Claude)
 */
const RELAY_SCRIPT_CONTENT = `#!/bin/bash
# DevChain relay script — bridges Claude Code hooks to DevChain's event API.
# Auto-generated by DevChain. Do not edit manually.
# Requires: jq, curl

set -euo pipefail

# Read Claude Code hook JSON from stdin
INPUT="$(cat)"

# Bail if no API URL configured
if [ -z "\${DEVCHAIN_API_URL:-}" ]; then
  exit 0
fi

# Extract hook event name from input
HOOK_EVENT_NAME="$(echo "$INPUT" | jq -r '.hook_event_name // empty')"
if [ -z "$HOOK_EVENT_NAME" ]; then
  exit 0
fi

# Capture tmux session name (fallback to env var if tmux unavailable)
TMUX_SESSION="\${DEVCHAIN_TMUX_SESSION_NAME:-}"
if [ -z "$TMUX_SESSION" ] && command -v tmux >/dev/null 2>&1; then
  TMUX_SESSION="$(tmux display-message -p '#S' 2>/dev/null || true)"
fi
if [ -z "$TMUX_SESSION" ]; then
  exit 0
fi

# Build combined payload: Claude Code fields + DevChain env vars
PAYLOAD="$(echo "$INPUT" | jq \\
  --arg hookEventName "$HOOK_EVENT_NAME" \\
  --arg claudeSessionId "$(echo "$INPUT" | jq -r '.session_id // empty')" \\
  --arg source "$(echo "$INPUT" | jq -r '.source // empty')" \\
  --arg model "$(echo "$INPUT" | jq -r '.model // empty')" \\
  --arg permissionMode "$(echo "$INPUT" | jq -r '.permission_mode // empty')" \\
  --arg transcriptPath "$(echo "$INPUT" | jq -r '.transcript_path // empty')" \\
  --arg tmuxSessionName "$TMUX_SESSION" \\
  --arg projectId "\${DEVCHAIN_PROJECT_ID:-}" \\
  --arg agentId "\${DEVCHAIN_AGENT_ID:-}" \\
  --arg sessionId "\${DEVCHAIN_SESSION_ID:-}" \\
  '{
    hookEventName: $hookEventName,
    claudeSessionId: $claudeSessionId,
    source: $source,
    tmuxSessionName: $tmuxSessionName,
    projectId: $projectId,
    agentId: (if $agentId == "" then null else $agentId end),
    sessionId: (if $sessionId == "" then null else $sessionId end)
  }
  + (if $model != "" then {model: $model} else {} end)
  + (if $permissionMode != "" then {permissionMode: $permissionMode} else {} end)
  + (if $transcriptPath != "" then {transcriptPath: $transcriptPath} else {} end)
  ')" || exit 0

# POST to DevChain API, capture response
RESPONSE="$(curl -s -f -X POST \\
  -H "Content-Type: application/json" \\
  -d "$PAYLOAD" \\
  "\${DEVCHAIN_API_URL}/api/hooks/events" \\
  --max-time 10 \\
  2>/dev/null)" || exit 0

# Bidirectional: output hook-compatible JSON if response contains data
if [ -n "$RESPONSE" ]; then
  # Check if response has non-empty data with additionalContext
  ADDITIONAL_CONTEXT="$(echo "$RESPONSE" | jq -r '.data.additionalContext // empty' 2>/dev/null)" || true
  if [ -n "$ADDITIONAL_CONTEXT" ]; then
    jq -n --arg ctx "$ADDITIONAL_CONTEXT" --arg evt "$HOOK_EVENT_NAME" '{
      hookSpecificOutput: {
        hookEventName: $evt,
        additionalContext: $ctx
      }
    }' 2>/dev/null || true
  fi
fi

exit 0
`;

interface ClaudeSettingsLocal {
  permissions?: {
    allow?: string[];
    deny?: string[];
    ask?: string[];
  };
  hooks?: Record<string, unknown>;
  [key: string]: unknown;
}

/**
 * HooksConfigService
 * Ensures .claude/settings.local.json and the relay script are correctly
 * deployed before a Claude session launches.
 */
@Injectable()
export class HooksConfigService {
  /**
   * Main entry point: ensures hooks config and relay script are in place.
   * Called during session launch — errors are logged but never throw
   * (non-fatal, same pattern as ProviderMcpEnsureService).
   */
  async ensureHooksConfig(projectRootPath: string): Promise<void> {
    try {
      await this.materializeRelayScript(projectRootPath);
      await this.mergeHooksSettings(projectRootPath);
      logger.info({ projectRootPath }, 'Hooks config ensured successfully');
    } catch (error) {
      logger.error({ error, projectRootPath }, 'Failed to ensure hooks config (non-fatal)');
    }
  }

  /**
   * Materialize the relay script to {projectRoot}/.claude/hooks/devchain-relay.sh.
   * Creates the directory if needed, writes atomically, sets chmod +x.
   */
  private async materializeRelayScript(projectRootPath: string): Promise<void> {
    const hooksDir = join(projectRootPath, '.claude', 'hooks');
    const scriptPath = join(hooksDir, 'devchain-relay.sh');
    const tempPath = `${scriptPath}.tmp-${process.pid}-${Date.now()}`;

    await mkdir(hooksDir, { recursive: true });

    try {
      await writeFile(tempPath, RELAY_SCRIPT_CONTENT, {
        encoding: 'utf-8',
        mode: SCRIPT_FILE_MODE,
      });
      await rename(tempPath, scriptPath);
      // Ensure executable after rename (some filesystems may not preserve mode)
      await chmod(scriptPath, SCRIPT_FILE_MODE);
      logger.debug({ scriptPath }, 'Relay script materialized');
    } catch (error) {
      try {
        await unlink(tempPath);
      } catch {
        // Ignore cleanup errors
      }
      throw error;
    }
  }

  /**
   * Deep-merge DevChain hook entries into .claude/settings.local.json.
   * Preserves existing permissions, user hooks, and all non-DevChain keys.
   * Uses atomic write (temp + rename) pattern.
   */
  private async mergeHooksSettings(projectRootPath: string): Promise<void> {
    const settingsDir = join(projectRootPath, '.claude');
    const settingsPath = join(settingsDir, 'settings.local.json');
    const tempPath = `${settingsPath}.tmp-${process.pid}-${Date.now()}`;
    const relayScriptPath = join(projectRootPath, '.claude', 'hooks', 'devchain-relay.sh');

    await mkdir(settingsDir, { recursive: true });

    // Read existing settings or start fresh
    let settings: ClaudeSettingsLocal;
    try {
      const content = await readFile(settingsPath, 'utf-8');
      settings = JSON.parse(content);
      if (typeof settings !== 'object' || settings === null || Array.isArray(settings)) {
        logger.warn(
          { settingsPath },
          'Invalid settings.local.json (not an object) — creating fresh',
        );
        settings = {};
      }
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        settings = {};
      } else if (error instanceof SyntaxError) {
        logger.warn({ settingsPath }, 'Invalid JSON in settings.local.json — creating fresh');
        settings = {};
      } else {
        throw error;
      }
    }

    // Build the DevChain hook entry
    const devchainHook = {
      type: 'command' as const,
      command: `"${relayScriptPath}"`,
      timeout: 10,
    };

    // Ensure hooks object exists
    if (!settings.hooks || typeof settings.hooks !== 'object') {
      settings.hooks = {};
    }

    // Merge SessionStart hooks — preserve user hooks, add/update DevChain entry
    const hooks = settings.hooks as Record<string, unknown>;
    const sessionStartEntries = Array.isArray(hooks.SessionStart) ? hooks.SessionStart : [];

    // Find existing DevChain matcher group or create one
    const devchainMarker = 'devchain-relay.sh';
    let devchainGroupFound = false;

    const updatedEntries = sessionStartEntries.map((entry: unknown) => {
      if (!isMatcherGroup(entry)) return entry;
      const hasDevchain = entry.hooks?.some(
        (h: unknown) =>
          isHookEntry(h) && typeof h.command === 'string' && h.command.includes(devchainMarker),
      );
      if (hasDevchain) {
        devchainGroupFound = true;
        return {
          ...entry,
          hooks: [devchainHook],
        };
      }
      return entry;
    });

    if (!devchainGroupFound) {
      updatedEntries.push({
        hooks: [devchainHook],
      });
    }

    hooks.SessionStart = updatedEntries;

    // Atomic write
    const output = JSON.stringify(settings, null, 2) + '\n';
    try {
      await writeFile(tempPath, output, { encoding: 'utf-8', mode: SETTINGS_FILE_MODE });
      await rename(tempPath, settingsPath);
      logger.debug({ settingsPath }, 'Hooks settings merged');
    } catch (error) {
      try {
        await unlink(tempPath);
      } catch {
        // Ignore cleanup errors
      }
      throw error;
    }
  }
}

function isMatcherGroup(value: unknown): value is { hooks?: unknown[]; matcher?: string } {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

function isHookEntry(value: unknown): value is { type?: string; command?: string } {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}
